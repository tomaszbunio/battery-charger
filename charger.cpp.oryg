
#include <Arduino.h>
#include <stdlib.h>

#include "display.h"
#include "check_page.h"
#include "common.h"
#include "sdcard.h"
#include "charger.h"

#include <string.h>

uint16_t intervals_min[26] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26 };
//uint16_t intervals_min[26] = { 30, 60, 90, 120, 180, 240, 300, 360, 420, 480, 540, 600, 660, 720, 780, 840, 900, 960, 1020, 1080, 1140, 1200, 1260, 1320, 1380, 1440 };
uint16_t intervals_h[18] = { 60, 120, 180, 240, 300, 360, 450, 540, 630, 720, 810, 900, 990, 1080, 1170, 1260, 1350, 1440 };
uint16_t intervals[26] = {};
uint16_t intervals_size = 18;

bool save_flags[26] = { false };
bool asym_ch = true;
bool asym_disch = false;
bool stor_alw_on = false;
bool float_alw_on = false;

String batt_abs_current[26] = {};
String abs_current = " ";
bool AutomaticEndOfCharging = false;

uint8_t li_battery_type = 1.25;
uint8_t load_div = 50;

float li_ion_currentOff = 0.05;
float last_capacity_disch;
float last_capacity_ch;
float elapsed_capacity_ch;
float elapsed_capacity_disch;
float cur_capacity_ch;
float cur_capacity_disch;
float prev_capacity_ch, prev_capacity_disch;
float li_normal_mode;
float li_fast_mode;

void run_charger(void) {

  if (charging_end == false) {

    switch (charger_state) {

      case initial:

        initial_Ah = ampHours;

        if (charging_type == fast_charging) charger_state = bulk;
        if (asym_mode == false) {

          if (busvoltage > MIN_BAT_VOLTS) {

            if (current_auto > ((battery[battery_type].capacity) / asymetry_charging) + 0.01) {
              pwm--;
              charge_pwm_duty();
            } else if (current_auto < ((battery[battery_type].capacity) / asymetry_charging) - 0.01) {
              pwm++;
              charge_pwm_duty();
            }
          } else (charger_state = off);
        }

        else if (asym_mode == true) {

          //************************************************************************************************

          if (asym_ch == true) {  // ładowanie

            if (current_auto > ((battery[battery_type].capacity) / charging_type) + 0.01) {
              pwm--;
              charge_pwm_duty();
            } else if (current_auto < (battery[battery_type].capacity) / charging_type - 0.01) {
              pwm++;
              charge_pwm_duty();
            }

            if ((ampHours - prev_capacity_ch) >= (battery[battery_type].capacity / 1000)) {  // jeśli ładunek władowany jest większy niż 0,004Ah
              prev_capacity_disch = ampHours_m;
              asym_ch = false;  // wyłącz ładowanie
              pwm = 2;
              charge_pwm_duty();
            }
          }

          if (asym_ch == false) {

            //************************************************************************************************

            discharge_pwm_duty(PWM_MAX);  // włącz rozładowanie

            if ((abs(ampHours_m) + prev_capacity_disch) >= (battery[battery_type].capacity / 2000)) {  // jeśli tymczasowy ładunek wyładowany jest większy niż 0,004Ah
              prev_capacity_ch = ampHours;
              asym_ch = true;  // włącz ładowanie
              discharge_pwm_duty(PWM_MIN);
            }
          }

          last_capacity_ch = ampHours;
          last_capacity_disch = ampHours_m;

          //*************************************** TRYB ASYM ********************************************

          if (asym_ch == true) Serial.print("ładowanie");
          else if (asym_ch == false) Serial.print("rozładowanie");
          Serial.print("  ");
          Serial.print(ampHours - prev_capacity_ch, 3);
          Serial.print("  ");
          Serial.print(ampHours_m - prev_capacity_disch, 3);
          Serial.print("  ");
          Serial.print(pwm);
          Serial.println("  ");
        }
        //*********************************** KONIEC TRYBU ASYM *******************************************

        if ((busvoltage >= NOM_BAT_VOLTS) || (battery_type == battery_li_2s) || (battery_type == battery_li_3s)) {
          Serial.println("+++++++++ bulk +++++++++");
          charger_state = bulk;
        }

        break;

      case bulk:

        bulk_Ah = ampHours - initial_Ah;

        if (busvoltage > battery[battery_type].u_bulk) {
          force_sd = true;
          logger_time();  // zapis do datalog.csv
          String abs_current = String("0") + "h = " + String(current_auto);
          appendFile(SD, current_filename, abs_current.c_str());
          appendFile(SD, current_filename, "\r\n");
          // pwm = 50;
          // charge_pwm_duty();
          mDelay(1000);
          //Serial.println("+++++++++ absorption +++++++++");
          //charger_state = absorption;
          Serial.println("+++++++++ storage +++++++++");
          charger_state = storage;
        }
        // dla baterii innej niż lipo

        if ((battery_type != battery_li_2s) && (battery_type != battery_li_3s)) {
          if (current_auto > ((battery[battery_type].capacity / charging_type) + 0.01)) {
            pwm--;
            charge_pwm_duty();
          } else if (current_auto < ((battery[battery_type].capacity / charging_type))) {
            mDelay(250);
            pwm++;
            charge_pwm_duty();
          }
        }

        else if (((battery_type == battery_li_2s) || (battery_type == battery_li_3s) && (charging_type == normal_charging))) {
          if (current_auto > li_battery_type + 0.25) {
            pwm--;
            charge_pwm_duty();
          } else if (current_auto < li_battery_type + 0.2) {
            mDelay(250);
            pwm++;
            charge_pwm_duty();
          }

        } else if (((battery_type == battery_li_2s) || (battery_type == battery_li_3s) && (charging_type == fast_charging))) {
          if (current_auto > 2 * (li_battery_type + 0.25)) {
            pwm--;
            charge_pwm_duty();
          } else if (current_auto < 2 * (li_battery_type + 0.2)) {
            mDelay(250);
            pwm++;
            charge_pwm_duty();
          }
        }

        break;
        //--------------------------------------------------------------------------------------------------------------------------
        //--------------------------------------------------------------------------------------------------------------------------

      case absorption:

        abs_Ah = ampHours - bulk_Ah - initial_Ah;

        if (charger_state == absorption) pid_pwm_duty();

        // zapis do SD odczytów prądu ładowania

        for (uint8_t i = 0; i < intervals_size; i++) {
          if (!save_flags[i] && minutess_abs == intervals[i]) {
            batt_abs_current[i] = String(current_auto, 2);
            String abs_current = String(intervals[i]) + "min = " + batt_abs_current[i] + "A";

            Serial.printf("i=%d batt_abs_current i=%sA\n", i, batt_abs_current[i].c_str());

            appendFile(SD, current_filename, abs_current.c_str());
            appendFile(SD, current_filename, "\r\n");
            save_flags[i] = true;
          }
        }

        // 2. Sprawdź warunek zakończenia absorption

        for (uint8_t i = 2; i < intervals_size; i++) {
          if (((battery_type != battery_li_2s) && (battery_type != battery_li_3s)) && (minutess_abs == intervals[i]) && (seconds_abs <= 1)) {

            float curr_now = batt_abs_current[i].toFloat();
            float curr_past = batt_abs_current[i - 2].toFloat();
            // Serial.println(curr_now);
            // Serial.println(curr_past);
            if ((curr_now >= curr_past) || (current_auto <= battery[battery_type].capacity / load_div)) {

              Serial.printf("batt_abs_current[i]=%.2f, batt_abs_current[i-2]=%.2f\n", curr_now, curr_past);
              Serial.println("case 0");
              appendFile(SD, current_filename, "Case 0: Current greater or equal ");
              pwm = 0;
              charge_pwm_duty();
              force_sd = true;
              logger_time();
              Serial.println("+++++++++ storage +++++++++");
              charger_state = storage;
              break;  // ❗ zatrzymaj po pierwszym spełnieniu
            }
          }
        }

        if ((battery_type == battery_li_2s) || (battery_type == battery_li_3s)) {
          if (current_auto <= li_ion_currentOff) {
            pwm = 2;
            charge_pwm_duty();
            Serial.println("case 0");
            appendFile(SD, current_filename, "Case 0: Current greater or equal ");
            force_sd = true;
            logger_time();
            stats_log();
            Serial.println("+++++++++ charging end +++++++++");
            charging_end = true;
            charger_state = off;
          }
        }

        break;
       
      case storage:

        storage_Ah = ampHours - abs_Ah - bulk_Ah - initial_Ah;

        if (charger_state == storage) pid_pwm_duty();
        if ((busvoltage > battery[battery_type].u_bulk) || (TIME_STORAGE <= minutess_storage)) {
          pwm = 0;
          charge_pwm_duty();
          //stats_log();
          force_sd = true;
          logger_time();
          Serial.println("Storage end");
          //charging_end = true;
          charger_state = bat_float;
        }

        break;

      case bat_float:

        float_Ah = ampHours - storage_Ah - abs_Ah - bulk_Ah - initial_Ah;

        if (charger_state == bat_float) pid_pwm_duty();
        if ((busvoltage > battery[battery_type].u_bulk) || (TIME_FLOAT <= minutess_float)) {
          AutomaticEndOfCharging = true;
          stats_log();
          force_sd = true;
          logger_time();
          Serial.println("Float end");
          charging_end = true;
          charger_state = off;
        }
        //}

        //-----------------------------------------------------------------------------------------------------------------------------------------------
        //-----------------------------------------------------------------------------------------------------------------------------------------------

      case off:

        if (charging_end == true) {
          charger_state = bat_disch;
          Serial.println(">>> switching to bat_disch");
        } else if (charging_end == false) {
          if (battery_type == battery_li_3s) {
            if (busvoltage >= min_voltage_li_3s) charger_state = bulk;
          } else if (battery_type == battery_li_2s) {
            if (busvoltage >= min_voltage_li_2s) charger_state = bulk;
          } else if ((battery_type != battery_li_2s) && (battery_type != battery_li_3s)) {
            if (busvoltage < BULK_BAT_VOLTS) charger_state = initial;
            else if (busvoltage >= BULK_BAT_VOLTS) {
              Serial.println("+++++++++ bulk +++++++++");
              charger_state = bulk;
            }
          }
        }

        break;


      case bat_disch:

        if (charging_end == true) {
          if (DischarSet) {
            if (abs(current_auto > CurrentDisch + 0.05)) pwm--;
            else if (abs(current_auto < CurrentDisch)) pwm++;
            Serial.print("bat_disch_mode");
          }
          discharge_pwm_duty(pwm);
        }
        break;
      default:
        pwm = 0;
        charge_pwm_duty();
        discharge_pwm_duty(0);
    }
  } else if ((charging_end == true) && (pwm_auto == false)) {
    charger_state = off;
    //pwm = 0;
    //charge_pwm_duty();
    //discharge_pwm_duty(0);
  }


  else if (charging_end == true) {
    charger_state = off;
    pwm = 0;
    charge_pwm_duty();
    //discharge_pwm_duty(pwm1);
  }
}


void pid_pwm_duty() {

  ledcWrite(pwm_charge_channel, pidValue);
  mDelay(1);
}

void charge_pwm_duty() {
  //if (!(charger_state == absorption)) {

  if ((charging_end == false) || (pwm_auto == false)) {
    if (pwm > PWM_MAX) {
      pwm = PWM_MAX;
    }
    if (pwm < PWM_MIN) {
      pwm = 0;
    }
    if (pwm < PWM_MAX) {
      ledcWrite(pwm_charge_channel, pwm);

    } else if (pwm == PWM_MAX) {
      ledcWrite(pwm_charge_channel, PWM_MAX - 1);
    }
  }

  if ((charging_end == true) && (pwm_auto == true))
    ledcWrite(pwm_charge_channel, PWM_MIN);

  //}

  // else if (charger_state == absorption) {
  //   ledcWrite(pwm_charge_channel, pidValue);
  //   delayMicroseconds(100);
  // }
}
void discharge_pwm_duty(uint16_t y) {

  // ledcAttachPin(DISCHARGE_PIN, pwm_discharge_channel);    // attach the channel to the GPIO to be controlled
  // ledcSetup(pwm_discharge_channel, discharging_freq, discharging_resolution);  // configure PWM functionalitites

  ledcWrite(pwm_discharge_channel, y);
  delayMicroseconds(100);
}
